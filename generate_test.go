package main

import (
	"bytes"
	"context"
	"fmt"
	"log"
	"os"
	"testing"
)

//generate gosingl test file use with caution
//go:generate ./gosingl -w github.com/alh1m1k/gosingl/test/interfaceType interfaceType
//go:generate ./gosingl -w github.com/alh1m1k/gosingl/test/mapType mapType
//go:generate ./gosingl -w --variable cbInstance --comment "random comment" github.com/alh1m1k/gosingl/test/callbackType CallbackType
//go:generate ./gosingl -w github.com/alh1m1k/gosingl/test/arraySliceType _arraySlice_
//go:generate ./gosingl -w github.com/alh1m1k/gosingl/test/empty empty
//go:generate ./gosingl -w github.com/alh1m1k/gosingl/test/composition composition
//go:generate ./gosingl -w github.com/alh1m1k/gosingl/test/split split
//go:generate ./gosingl -w github.com/alh1m1k/gosingl/test/deep deep

func TestInterface(t *testing.T) {
	ctx := context.Background()
	cfg := Config{
		Package:   "github.com/alh1m1k/gosingl/test/interfaceType",
		Structure: "interfaceType",
		Variable:  "Instance",
		Comment:   "Code generated by <git repo>. DO NOT EDIT.",
		Write:     true,
		Deep:      0,
	}

	b := &bytes.Buffer{}
	if err := ParsePackage(context.WithValue(ctx, "writer", b), cfg); err != nil {
		t.Fatal(err)
	}

	result, err := os.ReadFile("./test/interfaceType/interfaceType_singleton.go")
	if err != nil {
		t.Fatal(err)
	}
	if b.String() != string(result) {
		t.Fatalf("result is not the same as expected : %s\n %s", diff(b.String(), string(result), 10), b.String())
	}

}

func TestMap(t *testing.T) {
	ctx := context.Background()
	cfg := Config{
		Package:   "github.com/alh1m1k/gosingl/test/mapType",
		Structure: "mapType",
		Variable:  "Instance",
		Comment:   "Code generated by <git repo>. DO NOT EDIT.",
		Write:     true,
		Deep:      0,
	}

	b := &bytes.Buffer{}
	if err := ParsePackage(context.WithValue(ctx, "writer", b), cfg); err != nil {
		t.Fatal(err)
	}

	result, err := os.ReadFile("./test/mapType/mapType_singleton.go")
	if err != nil {
		t.Fatal(err)
	}

	if b.String() != string(result) {
		t.Fatalf("result is not the same as expected : %s\n %s", diff(b.String(), string(result), 10), b.String())
	}

}

func TestCallback(t *testing.T) {
	ctx := context.Background()
	cfg := Config{
		Package:   "github.com/alh1m1k/gosingl/test/callbackType",
		Structure: "CallbackType", //public structure //value structure(no ref)
		Variable:  "cbInstance",
		Comment:   "random comment",
		Write:     true,
		Deep:      0,
	}

	b := &bytes.Buffer{}
	if err := ParsePackage(context.WithValue(ctx, "writer", b), cfg); err != nil {
		t.Fatal(err)
	}

	result, err := os.ReadFile("./test/callbackType/callbackType_singleton.go")
	if err != nil {
		t.Fatal(err)
	}

	if b.String() != string(result) {
		t.Fatalf("result is not the same as expected : %s\n %s", diff(b.String(), string(result), 10), b.String())
	}

}

func TestSlice(t *testing.T) {
	ctx := context.Background()
	cfg := Config{
		Package:   "github.com/alh1m1k/gosingl/test/arraySliceType",
		Structure: "_arraySlice_",
		Variable:  "Instance",
		Comment:   "Code generated by <git repo>. DO NOT EDIT.",
		Write:     true,
		Deep:      0,
	}

	b := &bytes.Buffer{}
	if err := ParsePackage(context.WithValue(ctx, "writer", b), cfg); err != nil {
		t.Fatal(err)
	}

	result, err := os.ReadFile("./test/arraySliceType/arraySliceType_singleton.go")
	if err != nil {
		t.Fatal(err)
	}

	if b.String() != string(result) {
		t.Fatalf("result is not the same as expected : %s\n %s", diff(b.String(), string(result), 10), b.String())
	}

}

func TestEmpty(t *testing.T) {
	ctx := context.Background()
	cfg := Config{
		Package:   "github.com/alh1m1k/gosingl/test/empty",
		Structure: "empty", //public structure //value structure(no ref)
		Variable:  "Instance",
		Comment:   "Code generated by <git repo>. DO NOT EDIT.",
		Write:     true,
		Deep:      0,
	}

	b := &bytes.Buffer{}
	if err := ParsePackage(context.WithValue(ctx, "writer", b), cfg); err != nil {
		t.Fatal(err)
	}

	result, err := os.ReadFile("./test/empty/empty_singleton.go")
	if err != nil {
		t.Fatal(err)
	}

	if b.String() != string(result) {
		t.Fatalf("result is not the same as expected : %s\n %s", diff(b.String(), string(result), 10), b.String())
	}

}

func TestComposition(t *testing.T) {
	ctx := context.Background()
	cfg := Config{
		Package:   "github.com/alh1m1k/gosingl/test/composition",
		Structure: "composition", //public structure //value structure(no ref)
		Variable:  "Instance",
		Comment:   "Code generated by <git repo>. DO NOT EDIT.",
		Write:     true,
		Deep:      0,
	}

	b := &bytes.Buffer{}
	if err := ParsePackage(context.WithValue(ctx, "writer", b), cfg); err != nil {
		t.Fatal(err)
	}

	result, err := os.ReadFile("./test/composition/composition_singleton.go")
	if err != nil {
		t.Fatal(err)
	}

	if b.String() != string(result) {
		t.Fatalf("result is not the same as expected : %s\n %s", diff(b.String(), string(result), 10), b.String())
	}

}

func TestSplit(t *testing.T) {
	ctx := context.Background()
	cfg := Config{
		Package:   "github.com/alh1m1k/gosingl/test/split",
		Structure: "split", //public structure //value structure(no ref)
		Variable:  "Instance",
		Comment:   "Code generated by <git repo>. DO NOT EDIT.",
		Write:     true,
		Deep:      0,
	}

	b := &bytes.Buffer{}
	if err := ParsePackage(context.WithValue(ctx, "writer", b), cfg); err != nil {
		t.Fatal(err)
	}

	result, err := os.ReadFile("./test/split/split_singleton.go")
	if err != nil {
		t.Fatal(err)
	}

	if b.String() != string(result) {
		t.Fatalf("result is not the same as expected : %s\n %s", diff(b.String(), string(result), 10), b.String())
	}

}

func TestDeep(t *testing.T) {
	ctx := context.Background()
	cfg := Config{
		Package:   "github.com/alh1m1k/gosingl/test/deep",
		Structure: "deep", //public structure //value structure(no ref)
		Variable:  "Instance",
		Comment:   "Code generated by <git repo>. DO NOT EDIT.",
		Write:     true,
		Deep:      0,
	}

	b := &bytes.Buffer{}
	if err := ParsePackage(context.WithValue(ctx, "writer", b), cfg); err != nil {
		t.Fatal(err)
	}

	result, err := os.ReadFile("./test/deep/deep_singleton.go")
	if err != nil {
		t.Fatal(err)
	}

	if b.String() != string(result) {
		t.Fatalf("result is not the same as expected : %s\n %s", diff(b.String(), string(result), 10), b.String())
	}

}

func diff(generated, reference string, offset int) string {
	log.Println("str1:", len(generated), "str2:", len(reference))
	for i := 0; i < len(generated); i++ {
		if generated[i] != reference[i] {
			offset = min[int](offset, len(generated)-i)
			offset = min[int](offset, len(reference)-i)
			return fmt.Sprintf("symbol %d: gen: \"%s\" ref: \"%s\"", i, generated[i:i+offset], reference[i:i+offset])
		}
	}
	return ""
}

func min[T int](s ...T) T {
	if len(s) == 0 {
		var zero T
		return zero
	}
	m := s[0]
	for _, v := range s {
		if m > v {
			m = v
		}
	}
	return m
}
