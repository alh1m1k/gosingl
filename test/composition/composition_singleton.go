// Code generated by <git repo>. DO NOT EDIT.
package composition

import (
	"context"
	"crypto"
	"io"
	"net"
	"net/http"
	"net/url"
)

var Instance *composition

// <fmt.State> from fmt

func Width() (wid int, ok bool) {
	return Instance.State.Width()
}

func Precision() (prec int, ok bool) {
	return Instance.State.Precision()
}

func Flag(c int) bool {
	return Instance.State.Flag(c)
}

// <os.Signal> from os

func String() string {
	return Instance.Signal.String()
}

func Signal() {
	Instance.Signal.Signal()
}

// <http.Client> from net/http

func Get(url string) (resp *http.Response, err error) {
	return Instance.Client.Get(url)
}

func Do(req *http.Request) (*http.Response, error) {
	return Instance.Client.Do(req)
}

func Post(url, contentType string, body io.Reader) (resp *http.Response, err error) {
	return Instance.Client.Post(url, contentType, body)
}

func PostForm(url string, data url.Values) (resp *http.Response, err error) {
	return Instance.Client.PostForm(url, data)
}

func Head(url string) (resp *http.Response, err error) {
	return Instance.Client.Head(url)
}

func CloseIdleConnections() {
	Instance.Client.CloseIdleConnections()
}

func CheckRedirect(req *http.Request, via []*http.Request) error {
	return Instance.Client.CheckRedirect(req, via)
}

func Close() error {
	return Instance.Server.Close()
}

func Shutdown(ctx context.Context) error {
	return Instance.Server.Shutdown(ctx)
}

func RegisterOnShutdown(f func()) {
	Instance.Server.RegisterOnShutdown(f)
}

func ListenAndServe() error {
	return Instance.Server.ListenAndServe()
}

func Serve(l net.Listener) error {
	return Instance.Server.Serve(l)
}

func ServeTLS(l net.Listener, certFile, keyFile string) error {
	return Instance.Server.ServeTLS(l, certFile, keyFile)
}

func SetKeepAlivesEnabled(v bool) {
	Instance.Server.SetKeepAlivesEnabled(v)
}

func ListenAndServeTLS(certFile, keyFile string) error {
	return Instance.Server.ListenAndServeTLS(certFile, keyFile)
}

func ConnState(p0 net.Conn, p1 http.ConnState) {
	Instance.Server.ConnState(p0, p1)
}

func BaseContext(p0 net.Listener) context.Context {
	return Instance.Server.BaseContext(p0)
}

func ConnContext(ctx context.Context, c net.Conn) context.Context {
	return Instance.Server.ConnContext(ctx, c)
}

func Cookies() []*http.Cookie {
	return Instance.Response.Cookies()
}

func Location() (*url.URL, error) {
	return Instance.Response.Location()
}

func ProtoAtLeast(major, minor int) bool {
	return Instance.Response.ProtoAtLeast(major, minor)
}

// <crypto.Decrypter> from crypto

func Public() crypto.PublicKey {
	return Instance.Decrypter.Public()
}

func Decrypt(rand io.Reader, msg []byte, opts crypto.DecrypterOpts) (plaintext []byte, err error) {
	return Instance.Decrypter.Decrypt(rand, msg, opts)
}
