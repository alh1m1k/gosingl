package main

import (
	"errors"
	"fmt"
	"github.com/dave/jennifer/jen"
	"go/ast"
	"go/importer"
	"go/token"
	"go/types"
	"io"
	"log"
	"reflect"
)

var NoStructError = errors.New("no walid structure")

// generator will work on the selected structure of one file
type generator struct {
	defs         map[*ast.Ident]types.Object
	pkg          *types.Package
	fs           *token.FileSet
	files        []*ast.File
	structure    *ast.TypeSpec
	methods      []ast.Node
	buf          *jen.File
	pkgName      string
	dirName      string
	variableName string
	inited       bool
	w            io.Writer
}

func newGenerator(structure *ast.TypeSpec, methods []ast.Node, files []*ast.File, fs *token.FileSet, dirname string, pkgName string, variableName string, w io.Writer) *generator {
	return &generator{
		structure:    structure,
		methods:      methods,
		pkgName:      pkgName,
		w:            w,
		dirName:      dirname,
		variableName: variableName,
		fs:           fs,
		files:        files,
	}
}

func (g *generator) init() error {

	/**
	initializing package parsing with the go/type
	*/

	g.defs = make(map[*ast.Ident]types.Object)
	infos := &types.Info{
		Defs: g.defs,
	}

	config := types.Config{Importer: importer.Default(), FakeImportC: true}

	var err error
	g.pkg, err = config.Check(g.dirName, g.fs, g.files, infos)
	if err != nil {
		log.Println("Warning:", err)
		//return err
	}

	g.buf = jen.NewFilePathName(g.pkg.Path(), g.pkgName)
	g.buf.PackageComment("Code generated by <git repo>. DO NOT EDIT.")
	g.inited = true
	return nil
}

func (g *generator) do() error {

	if !g.inited {
		if err := g.init(); err != nil {
			return err
		}
	}

	if g.structure == nil {
		return NoStructError
	}

	var (
		structure    *ast.StructType
		ok, declared bool
	)
	if structure, ok = g.structure.Type.(*ast.StructType); !ok {
		return NoStructError
	}

	if len(g.methods) == 0 {
		g.buf.Var().Id(g.variableName).Op("*").Id(g.structure.Name.Name).Line()
		declared = true
	}

	for i := range g.methods {
		switch method := g.methods[i].(type) {
		case *ast.FuncDecl:
			if method.Name.IsExported() {
				if !declared {
					switch mType := method.Recv.List[0].Type.(type) {
					case *ast.StarExpr: //mb [T]
						g.buf.Var().Id(g.variableName).Op("*").Id(mType.X.(*ast.Ident).Name).Line()
					case *ast.Ident:
						g.buf.Var().Id(g.variableName).Id(mType.Name).Line()
					}
					declared = true
				}
				g.wrapFunction(method.Name.Name, method.Type.Params, method.Type.Results, method.Doc.Text())
				g.buf.Line()
			}
		default:
		}
	}

	for _, field := range structure.Fields.List {
		if fn, ok := field.Type.(*ast.FuncType); ok {
			if len(field.Names) > 0 && field.Names[0].IsExported() {
				g.wrapFunction(field.Names[0].Name, fn.Params, fn.Results, field.Doc.Text())
				g.buf.Line()
			}
		}
	}

	return g.buf.Render(g.w)
}

func (g *generator) wrapFunction(name string, in, out *ast.FieldList, comment string) {
	if len(comment) > 0 {
		g.buf.Comment(comment)
	}
	fnBuilder := g.buf.Func()
	fnBuilder.Id(name)
	if in.NumFields() > 0 {
		fnBuilder.Params(g.buildParams(in)...)
	}
	outFieldsCnt := out.NumFields()
	if out != nil && outFieldsCnt > 0 {
		if outFieldsCnt == 1 {
			fnBuilder.List(g.buildParams(out)...)
		} else {
			fnBuilder.Params(g.buildParams(out)...)
		}
	}
	fnBuilder.BlockFunc(func(grp *jen.Group) {
		grp.Return(jen.Id(g.variableName).Dot(name).CallFunc(func(group *jen.Group) {
			for _, field := range in.List {
				for _, fieldIdent := range field.Names {
					if _, ok := field.Type.(*ast.Ellipsis); ok {
						group.Add(jen.Id(fieldIdent.Name).Op("..."))
					} else {
						group.Add(jen.Id(fieldIdent.Name))
					}
				}
			}
		}))
	})
}

func (g *generator) buildParams(params *ast.FieldList) []jen.Code {
	var result []jen.Code
	for _, field := range params.List {
		var param *jen.Statement
		for _, fieldIdent := range field.Names {
			if param == nil {
				param = jen.Id(fieldIdent.Name)
			} else {
				param = param.Op(", ").Id(fieldIdent.Name)
			}
		}
		if param == nil { //anon param (probably return value)
			param = &jen.Statement{}
		}
		//log.Println(reflect.ValueOf(field.Type).String())
		param = g.recursBuildParam(field.Type, param)
		result = append(result, jen.Code(param))
		param = nil
	}
	return result
}

func (g *generator) recursBuildParam(param ast.Expr, root *jen.Statement) *jen.Statement {
	switch exp := param.(type) {
	case *ast.StarExpr:
		g.recursBuildParam(exp.X, root.Op("*"))
	case *ast.Ident:
		return root.Id(exp.Name)
	case *ast.Ellipsis:
		g.recursBuildParam(exp.Elt, root.Op("..."))
	case *ast.ArrayType:
		root.Op("[")
		if exp.Len != nil {
			g.recursBuildParam(exp.Len, root)
		}
		root.Op("]")
		g.recursBuildParam(exp.Elt, root)
	case *ast.SelectorExpr:
		g.recursBuildParam(exp.X, root)
		root.Op(".")
		g.recursBuildParam(exp.Sel, root)
		//log.Println(reflect.ValueOf(exp).String())
	default:
		log.Println(exp.Pos(), exp.End(), exp)
		panic(fmt.Sprintf("unsupported type %s", reflect.ValueOf(exp).String()))
	}
	return root
}
